{
  "version": 3,
  "sources": ["../../react-error-boundary/dist/src/index.ts", "../../react-error-boundary/dist/src/ErrorBoundary.ts", "../../react-error-boundary/dist/src/ErrorBoundaryContext.ts", "../../react-error-boundary/dist/src/useErrorBoundary.ts", "../../react-error-boundary/dist/src/assertErrorBoundaryContext.ts", "../../react-error-boundary/dist/src/withErrorBoundary.ts", "../../react-error-boundary/dist/src/types.ts"],
  "sourcesContent": ["\"use client\";\n\nexport * from \"./ErrorBoundary\";\nexport * from \"./ErrorBoundaryContext\";\nexport * from \"./useErrorBoundary\";\nexport * from \"./withErrorBoundary\";\n\n// TypeScript types\nexport * from \"./types\";\n", "import {\n  Component,\n  createElement,\n  ErrorInfo,\n  isValidElement,\n  PropsWithChildren,\n  PropsWithRef,\n  ReactElement,\n} from \"react\";\nimport { ErrorBoundaryContext } from \"./ErrorBoundaryContext\";\nimport { ErrorBoundaryProps, FallbackProps } from \"./types\";\n\ntype ErrorBoundaryState = { didCatch: boolean; error: any };\n\nconst initialState: ErrorBoundaryState = {\n  didCatch: false,\n  error: null,\n};\n\nexport class ErrorBoundary extends Component<\n  PropsWithRef<PropsWithChildren<ErrorBoundaryProps>>,\n  ErrorBoundaryState\n> {\n  state = initialState;\n\n  static getDerivedStateFromError(error: Error) {\n    return { didCatch: true, error };\n  }\n\n  resetErrorBoundary = (...args: any[]) => {\n    const { error } = this.state;\n\n    if (error !== null) {\n      this.props.onReset?.({\n        args,\n        reason: \"imperative-api\",\n      });\n\n      this.setState(initialState);\n    }\n  };\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    this.props.onError?.(error, info);\n  }\n\n  componentDidUpdate(\n    prevProps: ErrorBoundaryProps,\n    prevState: ErrorBoundaryState\n  ) {\n    const { didCatch } = this.state;\n    const { resetKeys } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (\n      didCatch &&\n      prevState.error !== null &&\n      hasArrayChanged(prevProps.resetKeys, resetKeys)\n    ) {\n      this.props.onReset?.({\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\",\n      });\n\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const { children, fallbackRender, FallbackComponent, fallback } =\n      this.props;\n    const { didCatch, error } = this.state;\n\n    let childToRender = children;\n\n    if (didCatch) {\n      const props: FallbackProps = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary,\n      };\n\n      if (isValidElement(fallback)) {\n        childToRender = fallback;\n      } else if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else {\n        throw new Error(\n          \"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\"\n        );\n      }\n    }\n\n    return createElement(\n      ErrorBoundaryContext.Provider,\n      {\n        value: {\n          didCatch,\n          error,\n          resetErrorBoundary: this.resetErrorBoundary,\n        },\n      },\n      childToRender\n    ) as ReactElement;\n  }\n}\n\nfunction hasArrayChanged(a: any[] = [], b: any[] = []) {\n  return (\n    a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))\n  );\n}\n", "import { createContext } from \"react\";\n\nexport type ErrorBoundaryContextType = {\n  didCatch: boolean;\n  error: any;\n  resetErrorBoundary: (...args: any[]) => void;\n};\n\nexport const ErrorBoundaryContext =\n  createContext<ErrorBoundaryContextType | null>(null);\n", "import { useContext, useMemo, useState } from \"react\";\nimport { assertErrorBoundaryContext } from \"./assertErrorBoundaryContext\";\nimport { ErrorBoundaryContext } from \"./ErrorBoundaryContext\";\n\nexport type UseErrorBoundaryApi<Error> = {\n  resetBoundary: () => void;\n  showBoundary: (error: Error) => void;\n};\n\nexport function useErrorBoundary<Error = any>(): UseErrorBoundaryApi<Error> {\n  const context = useContext(ErrorBoundaryContext);\n\n  assertErrorBoundaryContext(context);\n\n  const [state, setState] = useState<{\n    error: Error | null;\n    hasError: boolean;\n  }>({\n    error: null,\n    hasError: false,\n  });\n\n  const memoized = useMemo(\n    () => ({\n      resetBoundary: () => {\n        context?.resetErrorBoundary();\n        setState({ error: null, hasError: false });\n      },\n      showBoundary: (error: Error) =>\n        setState({\n          error,\n          hasError: true,\n        }),\n    }),\n    [context?.resetErrorBoundary]\n  );\n\n  if (state.hasError) {\n    throw state.error;\n  }\n\n  return memoized;\n}\n", "import { ErrorBoundaryContextType } from \"./ErrorBoundaryContext\";\n\nexport function assertErrorBoundaryContext(\n  value: any\n): value is ErrorBoundaryContextType {\n  if (\n    value == null ||\n    typeof value.didCatch !== \"boolean\" ||\n    typeof value.resetErrorBoundary !== \"function\"\n  ) {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n\n  return true;\n}\n", "import {\n  createElement,\n  forwardRef,\n  ForwardedRef,\n  RefAttributes,\n  ForwardRefExoticComponent,\n  PropsWithoutRef,\n  ComponentType,\n} from \"react\";\nimport { ErrorBoundary } from \"./ErrorBoundary\";\nimport { ErrorBoundaryProps } from \"./types\";\n\nexport function withErrorBoundary<Props extends Object>(\n  component: ComponentType<Props>,\n  errorBoundaryProps: ErrorBoundaryProps\n): ForwardRefExoticComponent<PropsWithoutRef<Props> & RefAttributes<any>> {\n  const Wrapped = forwardRef<ComponentType<Props>, Props>(\n    (props: Props, ref: ForwardedRef<ComponentType<Props>>) =>\n      createElement(\n        ErrorBoundary,\n        errorBoundaryProps,\n        createElement(component, { ...props, ref })\n      )\n  );\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = `withErrorBoundary(${name})`;\n\n  return Wrapped;\n}\n", "import {\n  Component,\n  ComponentType,\n  FunctionComponent,\n  ReactElement,\n  ReactNode,\n} from \"react\";\n\ndeclare function FallbackRender(props: FallbackProps): ReactNode;\n\nexport type FallbackProps = {\n  error: any;\n  resetErrorBoundary: (...args: any[]) => void;\n};\n\ntype ErrorBoundarySharedProps = {\n  onError?: (error: Error, info: { componentStack: string }) => void;\n  onReset?: (\n    details:\n      | { reason: \"imperative-api\"; args: any[] }\n      | { reason: \"keys\"; prev: any[] | undefined; next: any[] | undefined }\n  ) => void;\n  resetKeys?: any[];\n};\n\nexport type ErrorBoundaryPropsWithComponent = ErrorBoundarySharedProps & {\n  fallback?: never;\n  FallbackComponent: ComponentType<FallbackProps>;\n  fallbackRender?: never;\n};\n\nexport type ErrorBoundaryPropsWithRender = ErrorBoundarySharedProps & {\n  fallback?: never;\n  FallbackComponent?: never;\n  fallbackRender: typeof FallbackRender;\n};\n\nexport type ErrorBoundaryPropsWithFallback = ErrorBoundarySharedProps & {\n  fallback: ReactElement<\n    unknown,\n    string | FunctionComponent | typeof Component\n  > | null;\n  FallbackComponent?: never;\n  fallbackRender?: never;\n};\n\nexport type ErrorBoundaryProps =\n  | ErrorBoundaryPropsWithFallback\n  | ErrorBoundaryPropsWithComponent\n  | ErrorBoundaryPropsWithRender;\n"],
  "mappings": "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",
  "names": ["$hgUW1$createContext", "$hgUW1$Component", "$hgUW1$isValidElement", "$hgUW1$createElement", "$hgUW1$useContext", "$hgUW1$useState", "$hgUW1$useMemo", "$hgUW1$forwardRef"]
}
