import {isValidElement as $hgUW1$isValidElement, createElement as $hgUW1$createElement, Component as $hgUW1$Component, createContext as $hgUW1$createContext, useContext as $hgUW1$useContext, useState as $hgUW1$useState, useMemo as $hgUW1$useMemo, forwardRef as $hgUW1$forwardRef} from "react";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $44d7e150ebc754d2$exports = {};

$parcel$export($44d7e150ebc754d2$exports, "ErrorBoundary", () => $44d7e150ebc754d2$export$e926676385687eaf);

var $ebb31c7feaa4405e$exports = {};

$parcel$export($ebb31c7feaa4405e$exports, "ErrorBoundaryContext", () => $ebb31c7feaa4405e$export$b16d9fb1a22de840);

const $ebb31c7feaa4405e$export$b16d9fb1a22de840 = (0, $hgUW1$createContext)(null);


const $44d7e150ebc754d2$var$initialState = {
    didCatch: false,
    error: null
};
class $44d7e150ebc754d2$export$e926676385687eaf extends (0, $hgUW1$Component) {
    state = $44d7e150ebc754d2$var$initialState;
    static getDerivedStateFromError(error) {
        return {
            didCatch: true,
            error: error
        };
    }
    resetErrorBoundary = (...args)=>{
        const { error: error  } = this.state;
        if (error !== null) {
            this.props.onReset?.({
                args: args,
                reason: "imperative-api"
            });
            this.setState($44d7e150ebc754d2$var$initialState);
        }
    };
    componentDidCatch(error, info) {
        this.props.onError?.(error, info);
    }
    componentDidUpdate(prevProps, prevState) {
        const { didCatch: didCatch  } = this.state;
        const { resetKeys: resetKeys  } = this.props;
        // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,
        // we'd end up resetting the error boundary immediately.
        // This would likely trigger a second error to be thrown.
        // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.
        if (didCatch && prevState.error !== null && $44d7e150ebc754d2$var$hasArrayChanged(prevProps.resetKeys, resetKeys)) {
            this.props.onReset?.({
                next: resetKeys,
                prev: prevProps.resetKeys,
                reason: "keys"
            });
            this.setState($44d7e150ebc754d2$var$initialState);
        }
    }
    render() {
        const { children: children , fallbackRender: fallbackRender , FallbackComponent: FallbackComponent , fallback: fallback  } = this.props;
        const { didCatch: didCatch , error: error  } = this.state;
        let childToRender = children;
        if (didCatch) {
            const props = {
                error: error,
                resetErrorBoundary: this.resetErrorBoundary
            };
            if ((0, $hgUW1$isValidElement)(fallback)) childToRender = fallback;
            else if (typeof fallbackRender === "function") childToRender = fallbackRender(props);
            else if (FallbackComponent) childToRender = (0, $hgUW1$createElement)(FallbackComponent, props);
            else throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
        }
        return (0, $hgUW1$createElement)((0, $ebb31c7feaa4405e$export$b16d9fb1a22de840).Provider, {
            value: {
                didCatch: didCatch,
                error: error,
                resetErrorBoundary: this.resetErrorBoundary
            }
        }, childToRender);
    }
}
function $44d7e150ebc754d2$var$hasArrayChanged(a = [], b = []) {
    return a.length !== b.length || a.some((item, index)=>!Object.is(item, b[index]));
}



var $7c3c25b3f398a9d6$exports = {};

$parcel$export($7c3c25b3f398a9d6$exports, "useErrorBoundary", () => $7c3c25b3f398a9d6$export$c052f6604b7d51fe);

function $75c9d331f9c1ed1a$export$f20aa86254872370(value) {
    if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") throw new Error("ErrorBoundaryContext not found");
    return true;
}



function $7c3c25b3f398a9d6$export$c052f6604b7d51fe() {
    const context = (0, $hgUW1$useContext)((0, $ebb31c7feaa4405e$export$b16d9fb1a22de840));
    (0, $75c9d331f9c1ed1a$export$f20aa86254872370)(context);
    const [state, setState] = (0, $hgUW1$useState)({
        error: null,
        hasError: false
    });
    const memoized = (0, $hgUW1$useMemo)(()=>({
            resetBoundary: ()=>{
                context?.resetErrorBoundary();
                setState({
                    error: null,
                    hasError: false
                });
            },
            showBoundary: (error)=>setState({
                    error: error,
                    hasError: true
                })
        }), [
        context?.resetErrorBoundary
    ]);
    if (state.hasError) throw state.error;
    return memoized;
}


var $62ff477d53f02a5b$exports = {};

$parcel$export($62ff477d53f02a5b$exports, "withErrorBoundary", () => $62ff477d53f02a5b$export$f0c7a449e0cfaec7);


function $62ff477d53f02a5b$export$f0c7a449e0cfaec7(component, errorBoundaryProps) {
    const Wrapped = (0, $hgUW1$forwardRef)((props, ref)=>(0, $hgUW1$createElement)((0, $44d7e150ebc754d2$export$e926676385687eaf), errorBoundaryProps, (0, $hgUW1$createElement)(component, {
            ...props,
            ref: ref
        })));
    // Format for display in DevTools
    const name = component.displayName || component.name || "Unknown";
    Wrapped.displayName = `withErrorBoundary(${name})`;
    return Wrapped;
}


var $81c1b644006d48ec$exports = {};


"use client";


export {$44d7e150ebc754d2$export$e926676385687eaf as ErrorBoundary, $ebb31c7feaa4405e$export$b16d9fb1a22de840 as ErrorBoundaryContext, $7c3c25b3f398a9d6$export$c052f6604b7d51fe as useErrorBoundary, $62ff477d53f02a5b$export$f0c7a449e0cfaec7 as withErrorBoundary};
//# sourceMappingURL=react-error-boundary.module.js.map
